This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
LICENSE
pyproject.toml
README.md
src/__init__.py
src/cli.py
src/constants.py
src/scripts.py
src/server.py
src/styles.py
src/ui.py
src/upload.py
src/utils.py
vortex.egg-info/dependency_links.txt
vortex.egg-info/entry_points.txt
vortex.egg-info/PKG-INFO
vortex.egg-info/SOURCES.txt
vortex.egg-info/top_level.txt
vortex.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
\__pycache__
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Colvyn Harris Mathan Mohan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "vortex"
version = "1.0.0"
description = "Fast, cross-platform file transfer between devices over local Wi-Fi"
readme = "README.md"
license = {text = "MIT"}
requires-python = ">=3.8"
authors = [
    {name = "Colvyn"}
]
keywords = ["file-transfer", "http-server", "wifi", "cross-platform"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Environment :: Console",
    "Intended Audience :: End Users/Desktop",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Topic :: Internet :: WWW/HTTP :: HTTP Servers",
    "Topic :: System :: Filesystems",
]

[project.scripts]
vortex = "src.cli:main"

[project.urls]
Repository = "https://github.com/colvyn01/vortex"

[tool.setuptools.packages.find]
where = ["."]
include = ["src*"]
</file>

<file path="src/constants.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
Constants and configuration values for Vortex.

This module centralizes all magic numbers, configuration defaults, and
static mappings used throughout the application. Keeping constants in
one place makes the codebase easier to configure and maintain.
"""

# --- Encoding ---

ENCODING = "utf-8"

# --- Content Types ---

CONTENT_TYPE_HTML = "text/html; charset=utf-8"
CONTENT_TYPE_MULTIPART = "multipart/form-data"
CONTENT_TYPE_OCTET = "application/octet-stream"
CONTENT_TYPE_ZIP = "application/zip"

# --- Network Defaults ---

FALLBACK_IP = "127.0.0.1"
DNS_SERVER = ("8.8.8.8", 80)  # Used to detect local IP via UDP socket trick

# --- Streaming Configuration ---

# Chunk size for streaming file reads/writes.
# 64KB provides good balance between memory usage and throughput.
CHUNK_SIZE = 64 * 1024

# Maximum size for multipart form headers before rejecting request.
# Prevents memory exhaustion from malformed or malicious requests.
MAX_HEADER_SIZE = 8 * 1024

# --- Thread Pool Configuration ---

# Maximum concurrent connections the server will handle.
# Prevents resource exhaustion under high load.
MAX_WORKERS = 100

# --- MIME Type Mapping ---
# Comprehensive mapping of file extensions to MIME types.
# Organized by category for maintainability.

MIME_TYPES = {
    # --- Video Formats ---
    ".mp4": "video/mp4",
    ".m4v": "video/mp4",
    ".mkv": "video/x-matroska",
    ".webm": "video/webm",
    ".avi": "video/x-msvideo",
    ".mov": "video/quicktime",
    ".wmv": "video/x-ms-wmv",
    ".flv": "video/x-flv",
    ".ogv": "video/ogg",
    ".3gp": "video/3gpp",
    ".3g2": "video/3gpp2",
    ".ts": "video/mp2t",
    ".m2ts": "video/mp2t",
    ".mts": "video/mp2t",
    ".vob": "video/dvd",
    ".mpg": "video/mpeg",
    ".mpeg": "video/mpeg",
    # --- Audio Formats ---
    ".mp3": "audio/mpeg",
    ".m4a": "audio/mp4",
    ".m4b": "audio/mp4",  # Audiobook
    ".m4p": "audio/mp4",  # Protected audio
    ".m4r": "audio/mp4",  # Ringtone
    ".aac": "audio/aac",
    ".ogg": "audio/ogg",
    ".oga": "audio/ogg",
    ".opus": "audio/opus",
    ".flac": "audio/flac",
    ".wav": "audio/wav",
    ".wma": "audio/x-ms-wma",
    ".aiff": "audio/aiff",
    ".aif": "audio/aiff",
    ".aifc": "audio/aiff",  # Compressed AIFF
    ".caf": "audio/x-caf",  # Core Audio Format
    ".mid": "audio/midi",
    ".midi": "audio/midi",
    ".weba": "audio/webm",
    ".mka": "audio/x-matroska",
    # --- Image Formats ---
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".svg": "image/svg+xml",
    ".ico": "image/x-icon",
    ".bmp": "image/bmp",
    ".tiff": "image/tiff",
    ".tif": "image/tiff",
    ".heic": "image/heic",  # Apple photo format
    ".heif": "image/heif",  # Apple photo format
    ".heics": "image/heic-sequence",  # Apple photo sequence
    ".avif": "image/avif",
    ".raw": "image/raw",
    ".cr2": "image/x-canon-cr2",  # Canon RAW
    ".nef": "image/x-nikon-nef",  # Nikon RAW
    ".arw": "image/x-sony-arw",  # Sony RAW
    ".dng": "image/dng",  # Adobe Digital Negative / ProRAW
    # --- Document Formats ---
    ".pdf": "application/pdf",
    ".doc": "application/msword",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".xls": "application/vnd.ms-excel",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".odt": "application/vnd.oasis.opendocument.text",
    ".ods": "application/vnd.oasis.opendocument.spreadsheet",
    ".txt": "text/plain",
    ".rtf": "application/rtf",
    ".csv": "text/csv",
    ".json": "application/json",
    ".xml": "application/xml",
    ".html": "text/html",
    ".htm": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".md": "text/markdown",
    # --- Archive Formats ---
    ".zip": "application/zip",
    ".rar": "application/vnd.rar",
    ".7z": "application/x-7z-compressed",
    ".tar": "application/x-tar",
    ".gz": "application/gzip",
    ".bz2": "application/x-bzip2",
    ".xz": "application/x-xz",
    # --- Streaming Playlist Formats ---
    ".m3u": "audio/x-mpegurl",
    ".m3u8": "application/vnd.apple.mpegurl",
    ".pls": "audio/x-scpls",
    # --- Font Formats ---
    ".woff": "font/woff",
    ".woff2": "font/woff2",
    ".ttf": "font/ttf",
    ".otf": "font/otf",
    ".eot": "application/vnd.ms-fontobject",
    # --- Other Common Formats ---
    ".apk": "application/vnd.android.package-archive",
    ".exe": "application/x-msdownload",
    ".dmg": "application/x-apple-diskimage",
    ".iso": "application/x-iso9660-image",
    ".torrent": "application/x-bittorrent",
}
</file>

<file path="src/scripts.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
JavaScript for Vortex web interface.

This module contains the client-side JavaScript that handles file selection
display and parallel multi-file uploads with progress tracking.
"""

JS_UPLOAD_HANDLER = """
document.addEventListener('DOMContentLoaded', function() {
  // ==========================================================================
  // CONFIGURATION
  // ==========================================================================

  // Maximum number of simultaneous upload connections.
  // Higher values can improve throughput but may overwhelm slower networks.
  var MAX_PARALLEL = 4;


  // ==========================================================================
  // FILE INPUT DISPLAY
  // ==========================================================================
  // Update the filename display when user selects files.

  var fileInputs = document.querySelectorAll('.file-input input[type="file"]');

  fileInputs.forEach(function(input) {
    input.addEventListener('change', function() {
      var label = input.closest('.file-input');
      if (!label) return;

      var nameSpan = label.querySelector('.file-name');
      if (!nameSpan) return;

      if (input.files && input.files.length > 0) {
        if (input.files.length === 1) {
          nameSpan.textContent = input.files[0].name;
        } else {
          nameSpan.textContent = input.files.length + ' files selected';
        }
      } else {
        nameSpan.textContent = 'No file selected';
      }
    });
  });


  // ==========================================================================
  // PARALLEL MULTI-FILE UPLOAD
  // ==========================================================================
  // Handles uploading multiple files simultaneously with aggregate progress.

  var uploadForm = document.querySelector('form[enctype="multipart/form-data"]');

  if (uploadForm) {
    uploadForm.addEventListener('submit', function(e) {
      e.preventDefault();

      var fileInput = uploadForm.querySelector('input[type="file"]');
      if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        return;
      }

      // --- Initialize Upload State ---

      var files = Array.from(fileInput.files);
      var totalFiles = files.length;
      var totalBytes = files.reduce(function(sum, f) { return sum + f.size; }, 0);
      var uploadedBytes = 0;
      var completedFiles = 0;
      var failedFiles = [];
      var activeUploads = 0;
      var fileIndex = 0;

      // --- Get UI Elements ---

      var progressContainer = document.querySelector('.upload-progress');
      var progressBar = document.querySelector('.progress-bar');
      var progressText = document.querySelector('.progress-text');
      var uploadError = document.querySelector('.upload-error');
      var submitBtn = uploadForm.querySelector('button[type="submit"]');

      // Show progress UI, hide errors, disable submit
      if (progressContainer) progressContainer.classList.add('active');
      if (uploadError) {
        uploadError.classList.remove('active');
        uploadError.textContent = '';
      }
      if (submitBtn) submitBtn.disabled = true;

      // Track bytes uploaded per file for accurate progress calculation
      var fileProgress = {};

      // --- Progress Update Function ---

      function updateProgress() {
        var currentUploaded = uploadedBytes;
        for (var key in fileProgress) {
          currentUploaded += fileProgress[key];
        }
        var percent = totalBytes > 0
          ? Math.round((currentUploaded / totalBytes) * 100)
          : 0;

        if (progressBar) {
          progressBar.style.width = percent + '%';
        }
        if (progressText) {
          progressText.textContent =
            formatSize(currentUploaded) + ' / ' + formatSize(totalBytes) +
            ' (' + percent + '%) - ' + completedFiles + '/' + totalFiles + ' files';
        }
      }

      // --- Upload Queue Manager ---
      // Starts uploads up to MAX_PARALLEL at a time.

      function uploadNext() {
        while (activeUploads < MAX_PARALLEL && fileIndex < files.length) {
          uploadFile(files[fileIndex], fileIndex);
          fileIndex++;
        }
      }

      // --- Single File Upload Function ---

      function uploadFile(file, idx) {
        activeUploads++;
        fileProgress[idx] = 0;

        var formData = new FormData();
        formData.append('file', file);

        var xhr = new XMLHttpRequest();

        // Track upload progress for this file
        xhr.upload.addEventListener('progress', function(e) {
          if (e.lengthComputable) {
            fileProgress[idx] = e.loaded;
            updateProgress();
          }
        });

        // Handle upload completion
        xhr.addEventListener('load', function() {
          activeUploads--;
          delete fileProgress[idx];

          if (xhr.status >= 200 && xhr.status < 400) {
            completedFiles++;
            uploadedBytes += file.size;
          } else {
            failedFiles.push(file.name);
          }

          updateProgress();

          // Start next upload or handle completion
          if (fileIndex < files.length) {
            uploadNext();
          } else if (activeUploads === 0) {
            handleAllComplete();
          }
        });

        // Handle network errors
        xhr.addEventListener('error', function() {
          activeUploads--;
          delete fileProgress[idx];
          failedFiles.push(file.name);

          if (fileIndex < files.length) {
            uploadNext();
          } else if (activeUploads === 0) {
            handleAllComplete();
          }
        });

        xhr.open('POST', window.location.pathname, true);
        xhr.send(formData);
      }

      // --- Completion Handler ---

      function handleAllComplete() {
        if (failedFiles.length === 0) {
          // All uploads succeeded - refresh page to show new files
          window.location.reload();
        } else {
          // Some uploads failed - show error
          if (uploadError) {
            uploadError.textContent = 'Failed: ' + failedFiles.join(', ');
            uploadError.classList.add('active');
          }

          if (completedFiles > 0) {
            // Some succeeded - refresh after brief delay
            setTimeout(function() { window.location.reload(); }, 2000);
          } else {
            // All failed - reset UI for retry
            if (progressContainer) progressContainer.classList.remove('active');
            if (submitBtn) submitBtn.disabled = false;
          }
        }
      }

      // --- Start Upload ---
      uploadNext();
    });
  }


  // ==========================================================================
  // UTILITY FUNCTIONS
  // ==========================================================================

  /**
   * Format bytes as human-readable string (e.g., "1.5 MB").
   */
  function formatSize(bytes) {
    var units = ['B', 'KB', 'MB', 'GB', 'TB'];
    var i = 0;
    while (bytes >= 1024 && i < units.length - 1) {
      bytes /= 1024;
      i++;
    }
    return bytes.toFixed(1) + ' ' + units[i];
  }
});
"""
</file>

<file path="src/styles.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
CSS styles for Vortex web interface.

This module contains the complete stylesheet for the file browser UI.
The design follows a clean, minimal aesthetic with clear visual hierarchy
and responsive behavior for mobile devices.
"""

CSS_STYLESHEET = """
/* =============================================================================
   DESIGN SYSTEM & CSS VARIABLES
   ============================================================================= */

:root {
  /* --- Color Palette --- */
  --bg-color: #d8d8d8;
  --surface-color: #ffffff;
  --surface-alt: #fafafa;
  --text-main: #111111;
  --text-dim: #555555;

  /* --- Accent Colors --- */
  --accent-color: #ff3b00;
  --accent-hover: #e03200;
  --error-color: #cc0000;

  /* --- Borders --- */
  --border-color: #000000;
  --border-light: #dddddd;
  --border-width: 2px;

  /* --- Spacing & Sizing --- */
  --radius: 4px;

  /* --- Typography --- */
  --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Helvetica, Arial, sans-serif;
  --font-mono: "SF Mono", "Monaco", "Inconsolata", "Fira Mono",
    "Droid Sans Mono", monospace;
}


/* =============================================================================
   RESET & BASE STYLES
   ============================================================================= */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html,
body {
  height: 100%;
}

html {
  height: -webkit-fill-available;
}

body {
  background-color: var(--bg-color);
  background-image:
    linear-gradient(#cfcfcf 1px, transparent 1px),
    linear-gradient(90deg, #cfcfcf 1px, transparent 1px);
  background-size: 20px 20px;
  color: var(--text-main);
  font-family: var(--font-sans);
  min-height: 100vh;
  min-height: -webkit-fill-available;
  display: flex;
  justify-content: center;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overscroll-behavior-y: none;
}

.app-root {
  width: 100%;
  max-width: 1200px;
  padding: 0.75rem;
}


/* =============================================================================
   LAYOUT CONTAINER (Device Shell)
   ============================================================================= */

.device-shell {
  background: var(--surface-color);
  border: var(--border-width) solid var(--border-color);
  width: 100%;
  display: grid;
  grid-template-rows: auto auto 1fr auto;
  box-shadow: 10px 10px 0px rgba(0, 0, 0, 0.18);
  min-height: 0;
}

/* --- Desktop Layout --- */
@media (min-width: 900px) {
  body {
    align-items: center;
  }

  .app-root {
    padding: 1.5rem;
  }

  .device-shell {
    max-height: calc(100vh - 3rem);
  }
}

/* --- Mobile Layout --- */
@media (max-width: 600px) {
  body {
    background-size: 16px 16px;
  }

  .app-root {
    padding: 0;
  }

  .device-shell {
    border-width: 1px;
    box-shadow: none;
  }
}


/* =============================================================================
   HEADER
   ============================================================================= */

.device-header {
  padding: 0.9rem 1rem 0.4rem;
  border-bottom: var(--border-width) solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.device-header h1 {
  font-size: 0.95rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 800;
}

.device-header p {
  font-size: 0.8rem;
  color: var(--text-dim);
  line-height: 1.4;
  font-family: var(--font-mono);
}


/* =============================================================================
   SUBHEADER / PATH BAR
   ============================================================================= */

.device-subheader {
  padding: 0.4rem 1rem;
  border-bottom: 1px solid var(--border-color);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-dim);
  display: flex;
  justify-content: space-between;
  gap: 0.75rem;
}

.device-subheader span {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* =============================================================================
   MAIN CONTENT AREA
   ============================================================================= */

.device-main {
  padding: 0.8rem 1rem 0.8rem;
  display: grid;
  grid-template-columns: 1.9fr 1.1fr;
  column-gap: 1rem;
  row-gap: 0.75rem;
  min-height: 0;
}

/* --- Tablet/Mobile: Stack columns --- */
@media (max-width: 900px) {
  .device-main {
    grid-template-columns: 1fr;
    grid-auto-rows: auto;
  }

  /* Upload panel appears first on mobile */
  .panel-upload {
    order: -1;
  }
}


/* =============================================================================
   PANEL COMPONENT
   ============================================================================= */

.panel {
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--radius);
  background: #ffffff;
  padding: 0.75rem 0.9rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  min-width: 0;
  overflow: hidden;
}

.panel-title {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 800;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.panel-title span {
  font-family: var(--font-mono);
  font-size: 0.65rem;
  color: var(--text-dim);
}

.path-label {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-dim);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* =============================================================================
   FILE INPUT & UPLOAD CONTROLS
   ============================================================================= */

.upload-row {
  display: flex;
  flex-direction: column;
  gap: 0.6rem;
}

@media (min-width: 640px) {
  .upload-row {
    flex-direction: row;
    align-items: center;
  }
}

/* --- Custom File Input --- */

.file-input {
  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  font-family: var(--font-mono);
  font-size: 0.75rem;
  width: 100%;
}

.file-input input[type="file"] {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
  -webkit-appearance: none;
  font-size: 16px; /* Prevents iOS zoom on focus */
}

.file-button {
  background: var(--accent-color);
  color: #ffffff;
  border: var(--border-width) solid var(--border-color);
  padding: 0.4rem 0.9rem;
  text-transform: uppercase;
  font-weight: 700;
  letter-spacing: 0.5px;
  min-width: 7rem;
  text-align: center;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.file-name {
  flex: 1;
  padding: 0.3rem 0.5rem;
  border: 1px dashed #bbbbbb;
  color: var(--text-dim);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  background: #fafafa;
  min-height: 44px;
  display: flex;
  align-items: center;
}


/* =============================================================================
   BUTTONS
   ============================================================================= */

.btn {
  appearance: none;
  -webkit-appearance: none;
  background: #ffffff;
  border: var(--border-width) solid var(--border-color);
  color: var(--text-main);
  padding: 0.4rem 0.9rem;
  font-family: var(--font-mono);
  font-size: 0.75rem;
  text-transform: uppercase;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.08s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 6rem;
  min-height: 44px;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.btn:hover {
  background: var(--accent-color);
  color: #ffffff;
  transform: translateY(-1px);
  box-shadow: 2px 2px 0 var(--text-main);
}

.btn:active {
  transform: translateY(0);
  box-shadow: none;
  background: var(--accent-hover);
  color: #ffffff;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

/* --- Download All Button --- */

.btn-download {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  text-align: center;
  font-size: 0.7rem;
  padding: 0.35rem 0.6rem;
  min-height: 36px;
}

/* --- Mobile Button Adjustments --- */

@media (max-width: 600px) {
  .upload-row {
    flex-direction: column;
    gap: 0.5rem;
  }

  .file-input {
    flex-direction: column;
  }

  .file-button,
  .file-name,
  .btn {
    width: 100%;
  }
}


/* =============================================================================
   FILE LIST TABLE
   ============================================================================= */

.file-list {
  border-top: 1px solid var(--border-color);
  margin-top: 0.4rem;
  padding-top: 0.4rem;
  overflow: auto;
  min-height: 0;
  max-height: 100%;
  -webkit-overflow-scrolling: touch;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.75rem;
  font-family: var(--font-mono);
  table-layout: fixed;
}

th,
td {
  padding: 0.25rem 0.3rem;
  border-bottom: 1px solid var(--border-light);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

th {
  text-align: left;
  text-transform: uppercase;
  font-size: 0.6rem;
  letter-spacing: 0.5px;
  color: var(--text-dim);
  font-weight: 600;
}

td a {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
}


/* =============================================================================
   LINKS
   ============================================================================= */

a {
  color: var(--accent-color);
  text-decoration: none;
  font-family: var(--font-mono);
  -webkit-tap-highlight-color: transparent;
}

a:hover {
  color: var(--accent-hover);
  text-decoration: underline;
}

a:active {
  color: var(--accent-hover);
  opacity: 0.8;
}

/* --- Mobile Table Adjustments --- */

@media (max-width: 600px) {
  table {
    font-size: 0.7rem;
  }

  th,
  td {
    padding: 0.4rem 0.25rem;
  }

  th {
    font-size: 0.55rem;
  }

  /* Larger touch targets on mobile */
  td a {
    padding: 0.35rem 0;
    min-height: 38px;
    display: flex;
    align-items: center;
  }
}


/* =============================================================================
   FOOTER / STATUS BAR
   ============================================================================= */

.device-footer {
  padding: 0.5rem 1.25rem;
  border-top: var(--border-width) solid var(--border-color);
  background: var(--surface-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-family: var(--font-mono);
  font-size: 0.65rem;
}

.device-footer span.label {
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 700;
  color: var(--text-main);
}

.device-footer span.value {
  color: var(--text-dim);
}


/* =============================================================================
   UPLOAD PROGRESS INDICATOR
   ============================================================================= */

.upload-progress {
  display: none;
  flex-direction: column;
  gap: 0.5rem;
  margin-top: 0.6rem;
}

.upload-progress.active {
  display: flex;
}

.progress-bar-container {
  width: 100%;
  height: 10px;
  background: var(--surface-alt);
  border: 1px solid var(--border-light);
  border-radius: var(--radius);
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  width: 0%;
  background: var(--accent-color);
  border-radius: var(--radius);
  transition: width 0.15s ease;
}

.progress-text {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-secondary);
}


/* =============================================================================
   ERROR MESSAGES
   ============================================================================= */

.upload-error {
  color: var(--error-color);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  display: none;
  padding: 0.4rem 0.6rem;
  background: #fef2f2;
  border-radius: var(--radius);
  border: 1px solid var(--error-color);
}

.upload-error.active {
  display: block;
}
"""
</file>

<file path="src/upload.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
File upload handling for Vortex.

This module implements multipart form data parsing with streaming support
for memory-efficient handling of large file uploads. Files are streamed
directly to disk rather than being buffered entirely in memory.
"""

import os
import re
import tempfile
from dataclasses import dataclass
from io import BufferedIOBase
from typing import Optional, Union

from .constants import CHUNK_SIZE, ENCODING, MAX_HEADER_SIZE
from .utils import sanitize_filename


# --- Upload Result ---


@dataclass
class UploadResult:
    """
    Result of a file upload operation.

    Attributes:
        success: True if the upload completed successfully.
        error_message: Description of the error if success is False.
    """

    success: bool
    error_message: Optional[str] = None


# --- Multipart Parsing ---


def extract_boundary(content_type: str) -> Optional[str]:
    """
    Extract the multipart boundary string from a Content-Type header.

    The boundary is used to separate different parts in a multipart
    form submission.

    Args:
        content_type: The Content-Type header value.

    Returns:
        The boundary string, or None if not found.
    """
    match = re.search(r"boundary=(.+)", content_type)
    if not match:
        return None

    boundary = match.group(1).strip()

    # Remove surrounding quotes if present
    if boundary.startswith('"') and boundary.endswith('"'):
        boundary = boundary[1:-1]

    return boundary


def parse_multipart_streaming(
    rfile: Union[BufferedIOBase, "SocketIO"],  # type: ignore[name-defined]
    content_length: int,
    boundary: str,
    base_directory: str,
) -> UploadResult:
    """
    Parse multipart form data using streaming to handle large files.

    This function reads the upload in chunks and writes directly to disk,
    avoiding the need to buffer the entire file in memory. This allows
    uploads of arbitrarily large files without memory issues.

    The parsing works by:
    1. Finding the multipart boundary that separates form fields
    2. Extracting the filename from the Content-Disposition header
    3. Streaming file data to a temporary file
    4. Moving the temp file to the final destination on success

    Args:
        rfile: The request input stream (socket file object).
        content_length: Total bytes to read from the stream.
        boundary: The multipart boundary string.
        base_directory: Directory where uploaded files will be saved.

    Returns:
        UploadResult indicating success or failure with error message.
    """
    boundary_bytes = ("--" + boundary).encode(ENCODING)
    remaining = content_length

    # --- Phase 1: Find the first boundary ---
    # Read until we encounter the boundary that starts the file part.

    header_buffer = b""
    while remaining > 0 and boundary_bytes not in header_buffer:
        to_read = min(1024, remaining)
        chunk = rfile.read(to_read)
        if not chunk:
            break
        remaining -= len(chunk)
        header_buffer += chunk

        # Prevent memory exhaustion from malformed requests
        if len(header_buffer) > MAX_HEADER_SIZE:
            return UploadResult(success=False, error_message="Headers too large")

    # --- Phase 2: Parse headers after boundary ---
    # Extract Content-Disposition to get the filename.

    boundary_pos = header_buffer.find(boundary_bytes)
    if boundary_pos == -1:
        return UploadResult(success=False, error_message="No boundary found")

    # Skip past boundary and CRLF to reach headers
    header_start = boundary_pos + len(boundary_bytes)
    header_buffer = header_buffer[header_start:].lstrip(b"\r\n")

    # Read until we hit the double CRLF separating headers from body
    while b"\r\n\r\n" not in header_buffer and remaining > 0:
        to_read = min(1024, remaining)
        chunk = rfile.read(to_read)
        if not chunk:
            break
        remaining -= len(chunk)
        header_buffer += chunk

        if len(header_buffer) > MAX_HEADER_SIZE:
            return UploadResult(success=False, error_message="Headers too large")

    if b"\r\n\r\n" not in header_buffer:
        return UploadResult(success=False, error_message="Malformed multipart data")

    headers_block, file_data_start = header_buffer.split(b"\r\n\r\n", 1)
    headers_text = headers_block.decode(ENCODING, "replace")

    # Verify this is the file field we expect
    if 'name="file"' not in headers_text:
        return UploadResult(success=False, error_message="No file field found")

    # Extract filename from Content-Disposition header
    filename_match = re.search(r'filename="([^"]+)"', headers_text)
    if not filename_match:
        return UploadResult(success=False, error_message="No filename in upload")

    filename = os.path.basename(filename_match.group(1))
    filename = sanitize_filename(filename)
    if not filename:
        return UploadResult(success=False, error_message="Empty filename")

    dest_path = os.path.join(base_directory, filename)

    # --- Phase 3: Stream file data to temporary file ---
    # Write to temp file first, then move to destination atomically.
    # This prevents partial/corrupt files if the upload is interrupted.

    temp_fd = None
    temp_path = None

    try:
        temp_fd, temp_path = tempfile.mkstemp(dir=base_directory, prefix=".upload_")

        with os.fdopen(temp_fd, "wb") as temp_file:
            temp_fd = None  # fdopen takes ownership of the file descriptor

            # Check if the entire file was in the initial buffer
            boundary_pos = file_data_start.find(boundary_bytes)
            if boundary_pos != -1:
                # Small file: everything fit in the header buffer
                file_data = file_data_start[:boundary_pos]
                if file_data.endswith(b"\r\n"):
                    file_data = file_data[:-2]
                temp_file.write(file_data)
            else:
                # Large file: need to stream the rest
                # Keep a buffer for boundary detection at chunk boundaries
                boundary_len = len(boundary_bytes)

                if len(file_data_start) > boundary_len + 2:
                    # Write data that definitely isn't part of a boundary
                    safe_len = len(file_data_start) - boundary_len - 2
                    temp_file.write(file_data_start[:safe_len])
                    buffer = file_data_start[safe_len:]
                else:
                    buffer = file_data_start

                # Stream remaining data in chunks
                while remaining > 0:
                    to_read = min(CHUNK_SIZE, remaining)
                    chunk = rfile.read(to_read)
                    if not chunk:
                        break
                    remaining -= len(chunk)
                    buffer += chunk

                    # Check if we've hit the end boundary
                    boundary_pos = buffer.find(boundary_bytes)
                    if boundary_pos != -1:
                        # Found boundary - write everything before it
                        data_to_write = buffer[:boundary_pos]
                        if data_to_write.endswith(b"\r\n"):
                            data_to_write = data_to_write[:-2]
                        temp_file.write(data_to_write)
                        break

                    # Write safe portion, keep potential boundary overlap
                    safe_len = len(buffer) - boundary_len - 2
                    if safe_len > 0:
                        temp_file.write(buffer[:safe_len])
                        buffer = buffer[safe_len:]
                else:
                    # No boundary found - write remaining buffer
                    if buffer:
                        if buffer.endswith(b"\r\n"):
                            buffer = buffer[:-2]
                        if buffer.endswith(b"--"):
                            buffer = buffer[:-2]
                        temp_file.write(buffer)

        # --- Phase 4: Move temp file to final destination ---
        # Remove existing file if present, then atomic rename.

        if os.path.exists(dest_path):
            os.remove(dest_path)
        os.rename(temp_path, dest_path)
        temp_path = None  # Successfully moved

        return UploadResult(success=True)

    except OSError as e:
        return UploadResult(success=False, error_message=f"Failed to save file: {e}")

    finally:
        # Clean up temp file if it still exists (upload failed)
        if temp_fd is not None:
            try:
                os.close(temp_fd)
            except OSError:
                pass
        if temp_path is not None:
            try:
                os.unlink(temp_path)
            except OSError:
                pass
</file>

<file path="src/utils.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
Utility functions for Vortex.

This module provides helper functions for file handling, security validation,
MIME type detection, HTTP header parsing, and other common operations.
"""

import os
import re
from hashlib import md5
from pathlib import Path
from typing import Optional, Tuple

from .constants import CONTENT_TYPE_OCTET, MIME_TYPES

# --- Filename Sanitization ---

# Characters that are invalid in Windows filenames: \ / : * ? " < > |
INVALID_FILENAME_CHARS = re.compile(r'[\\/:*?"<>|]')


def sanitize_filename(filename: str) -> str:
    """
    Sanitize a filename by removing characters invalid on Windows.

    This ensures uploaded files can be saved on any filesystem without
    issues. Leading/trailing spaces and dots are also stripped.

    Args:
        filename: The original filename from the upload.

    Returns:
        A sanitized filename safe for all major filesystems.
        Returns "uploaded_file" if the result would be empty.
    """
    # Replace invalid characters with underscore
    sanitized = INVALID_FILENAME_CHARS.sub("_", filename)

    # Remove leading/trailing spaces and dots (problematic on Windows)
    sanitized = sanitized.strip(" .")

    # Fallback if filename is empty after sanitization
    if not sanitized:
        sanitized = "uploaded_file"

    return sanitized


# --- Path Security ---


def is_path_safe(path: Path, base_directory: Path) -> bool:
    """
    Check if a path is safely contained within the base directory.

    This prevents directory traversal attacks where malicious requests
    attempt to access files outside the served directory using sequences
    like "../" or absolute paths.

    Args:
        path: The path to validate (will be resolved to absolute).
        base_directory: The root directory that should contain the path.

    Returns:
        True if the path is safely within base_directory, False otherwise.
    """
    try:
        # Resolve both paths to absolute, resolving any symlinks
        resolved_path = path.resolve()
        resolved_base = base_directory.resolve()

        # Check if the resolved path starts with the base directory
        return resolved_path.is_relative_to(resolved_base)
    except (OSError, ValueError):
        # Any error in path resolution means it's not safe
        return False


# --- MIME Type Detection ---


def get_mime_type(file_path: str) -> str:
    """
    Get the MIME type for a file based on its extension.

    Uses a comprehensive mapping of common file extensions. Falls back
    to application/octet-stream for unknown extensions.

    Args:
        file_path: Path to the file (only extension is used).

    Returns:
        MIME type string (e.g., "video/mp4", "image/png").
    """
    ext = os.path.splitext(file_path)[1].lower()
    return MIME_TYPES.get(ext, CONTENT_TYPE_OCTET)


# --- HTTP Header Utilities ---


def generate_etag(file_path: str, file_stat: os.stat_result) -> str:
    """
    Generate an ETag for HTTP caching validation.

    The ETag is computed from the file path, size, and modification time.
    This allows browsers to efficiently check if their cached version
    is still valid without downloading the entire file.

    Args:
        file_path: Path to the file.
        file_stat: Result of os.stat() on the file.

    Returns:
        ETag string in quotes (e.g., '"abc123def456"').
    """
    etag_data = f"{file_path}:{file_stat.st_size}:{file_stat.st_mtime}"
    return f'"{md5(etag_data.encode()).hexdigest()}"'


def parse_range_header(range_header: str, file_size: int) -> Optional[Tuple[int, int]]:
    """
    Parse an HTTP Range header for partial content requests.

    Supports single-range requests only. Used for video/audio seeking
    and resumable downloads.

    Supported formats:
        - "bytes=0-1023"  : Bytes 0 through 1023 (inclusive)
        - "bytes=500-"    : From byte 500 to end of file
        - "bytes=-500"    : Last 500 bytes of file

    Args:
        range_header: The Range header value (e.g., "bytes=0-1023").
        file_size: Total size of the file in bytes.

    Returns:
        Tuple of (start, end) byte positions (inclusive), or None if
        the range is invalid or unsupported (e.g., multi-range).
    """
    # Range header must start with "bytes="
    if not range_header.startswith("bytes="):
        return None

    range_spec = range_header[6:].strip()

    # Multi-range requests are not supported
    if "," in range_spec:
        return None

    try:
        if range_spec.startswith("-"):
            # Suffix range: "-500" means last 500 bytes
            suffix_length = int(range_spec[1:])
            if suffix_length <= 0:
                return None
            start = max(0, file_size - suffix_length)
            end = file_size - 1

        elif range_spec.endswith("-"):
            # Open-ended range: "500-" means from byte 500 to end
            start = int(range_spec[:-1])
            end = file_size - 1

        else:
            # Explicit range: "0-1023"
            parts = range_spec.split("-")
            if len(parts) != 2:
                return None
            start = int(parts[0])
            end = int(parts[1])

        # Validate range bounds
        if start < 0 or end < start or start >= file_size:
            return None

        # Clamp end to file size (handle oversized range requests gracefully)
        end = min(end, file_size - 1)

        return (start, end)

    except ValueError:
        # Invalid integer in range specification
        return None
</file>

<file path="vortex.egg-info/dependency_links.txt">

</file>

<file path="vortex.egg-info/entry_points.txt">
[console_scripts]
vortex = src.cli:main
</file>

<file path="vortex.egg-info/PKG-INFO">
Metadata-Version: 2.4
Name: vortex
Version: 1.0.0
Summary: Fast, cross-platform file transfer between devices over local Wi-Fi
Author: Colvyn
License: MIT
Project-URL: Repository, https://github.com/colvyn01/vortex
Keywords: file-transfer,http-server,wifi,cross-platform
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Intended Audience :: End Users/Desktop
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Topic :: Internet :: WWW/HTTP :: HTTP Servers
Classifier: Topic :: System :: Filesystems
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: license-file

# vortex
</file>

<file path="vortex.egg-info/SOURCES.txt">
LICENSE
README.md
pyproject.toml
src/__init__.py
src/cli.py
src/server.py
src/ui.py
vortex.egg-info/PKG-INFO
vortex.egg-info/SOURCES.txt
vortex.egg-info/dependency_links.txt
vortex.egg-info/entry_points.txt
vortex.egg-info/top_level.txt
</file>

<file path="vortex.egg-info/top_level.txt">
src
</file>

<file path="vortex.py">
from src.cli import main

if __name__ == "__main__":
    main()
</file>

<file path="README.md">
# Vortex

Vortex is a zero-configuration file sharing server for local networks. It lets
you quickly share files between devices on the same Wi-Fi network through a
clean, responsive web interface.

No accounts, no cloud, no complicated setup. Just run the command and share the
URL with anyone on your network.


## Features

- Zero configuration required - works out of the box
- Upload and download files from any device with a web browser
- No file size limits - streaming transfers handle files of any size
- HTTP Range support for video/audio seeking and resumable downloads
- Download entire directories as ZIP archives
- Parallel multi-file uploads with progress tracking
- Cross-platform: Windows, macOS, Linux
- Mobile-friendly responsive design
- No external dependencies - pure Python standard library


## Requirements

- Python 3.8 or higher


## Installation

Clone the repository and install in development mode:

```sh
git clone https://github.com/colvyn01/vortex.git
cd vortex
pip install -e .
```

Or install directly:

```sh
pip install .
```


## Quick Start

Start the server in the current directory:

```sh
vortex --start
```

The server will display a URL like `http://192.168.1.100:8000/` that you can
share with other devices on your network.

To stop the server:

```sh
vortex --stop
```


## Usage

### Command Reference

| Command | Description |
|---------|-------------|
| `vortex --start` | Start the server in the current directory |
| `vortex --start --dir PATH` | Share a specific directory |
| `vortex --start --port 3000` | Use a custom port (default: 8000) |
| `vortex --stop` | Stop the running server |
| `vortex --help` | Show all available options |

### Examples

Share your Downloads folder on port 3000:

```sh
vortex --start --dir ~/Downloads --port 3000
```

Share the current directory with default settings:

```sh
vortex --start
```

### Web Interface

Once the server is running, open the displayed URL in any web browser:

- Browse files and directories
- Click any file to download it
- Click "Download All" to get all files in the current directory as a ZIP
- Use the upload panel to send files to the server


## Updating

To update Vortex to the latest version:

```sh
cd vortex
git pull
pip install -e .
```

Or if installed without `-e`:

```sh
cd vortex
git pull
pip install .
```


## Security Considerations

Vortex is designed for trusted local networks only. Keep the following in mind:

- **No encryption**: All traffic is plain HTTP. Do not use over untrusted networks.
- **No authentication**: Anyone with the URL can access and upload files.
- **LAN only**: The server binds to all interfaces but is intended for local use.
- **Path protection**: Directory traversal attacks are blocked, but only serve
  directories you trust.

For use cases requiring security, consider running behind a reverse proxy with
HTTPS and authentication, or use a different tool designed for public networks.


## Project Structure

```
vortex/
  src/
    __init__.py      # Package exports and version
    cli.py           # Command-line interface
    server.py        # HTTP server and request handler
    ui.py            # HTML template rendering
    upload.py        # Multipart upload parsing
    utils.py         # Utility functions
    constants.py     # Configuration constants
    styles.py        # CSS stylesheet
    scripts.py       # JavaScript for uploads
  vortex.py          # Entry point
  pyproject.toml     # Package configuration
  LICENSE            # MIT License
  README.md          # This file
```


## License

MIT License. See [LICENSE](LICENSE) for details.
</file>

<file path="src/__init__.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
Vortex - Simple local file gateway.

A zero-configuration file sharing server for local networks. Vortex provides
an easy way to share files between devices on the same Wi-Fi network through
a clean web interface.

Features:
    - No configuration required - just run and share
    - Upload and download files from any device with a browser
    - Streaming transfers for memory-efficient handling of large files
    - HTTP Range support for media seeking and resumable downloads
    - Cross-platform: Windows, macOS, Linux

Quick Start:
    $ vortex --start                    # Start server in current directory
    $ vortex --start --dir ~/Downloads  # Share a specific directory
    $ vortex --stop                     # Stop the running server

Example:
    >>> from src import run_server
    >>> run_server("/path/to/share", port=8000)
"""

# --- Public API ---
# These are the main entry points for using Vortex programmatically.

from .cli import main
from .server import PooledHTTPServer, VortexHandler, get_local_ip, run_server
from .ui import format_size, render_directory_listing, render_layout
from .utils import get_mime_type, is_path_safe

__all__ = [
    # CLI entry point
    "main",
    # Server components
    "run_server",
    "VortexHandler",
    "PooledHTTPServer",
    "get_local_ip",
    # UI rendering
    "render_directory_listing",
    "render_layout",
    # Utilities
    "format_size",
    "get_mime_type",
    "is_path_safe",
]

__version__ = "1.0.0"
</file>

<file path="src/cli.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
Command-line interface for Vortex file gateway.

This module handles argument parsing and process management for starting
and stopping the Vortex server. It provides cross-platform support for
Windows and Unix systems.
"""

import argparse
import os
import signal
import sys
from pathlib import Path
from typing import Optional

from .server import run_server


# =============================================================================
# CONFIGURATION DEFAULTS
# =============================================================================

DEFAULT_PORT = 8000
DEFAULT_DIR = "."
DEFAULT_MAX_PARALLEL = 4


# =============================================================================
# PID FILE MANAGEMENT
# =============================================================================
# The PID file stores the process ID of a running Vortex server, allowing
# the --stop command to find and terminate it. Location varies by platform.


def _get_pid_file() -> Path:
    """
    Get the path to the PID file.

    On Windows, uses LOCALAPPDATA or TEMP directory.
    On Unix, uses the home directory with a hidden file.

    Returns:
        Path object pointing to the PID file location.
    """
    if sys.platform == "win32":
        # Windows: use LOCALAPPDATA (e.g., C:/Users/Name/AppData/Local)
        # Falls back to TEMP if LOCALAPPDATA is not available
        app_data = os.environ.get("LOCALAPPDATA", os.environ.get("TEMP", "."))
        return Path(app_data) / "vortex.pid"
    else:
        # Unix/Linux/macOS: use home directory with hidden file
        return Path.home() / ".vortex.pid"


def _write_pid_file() -> None:
    """
    Write the current process ID to the PID file.

    This is called when starting the server so that --stop can find it later.
    Errors are silently ignored as PID file is non-critical functionality.
    """
    pid_file = _get_pid_file()
    try:
        pid_file.write_text(str(os.getpid()))
    except OSError:
        pass  # Non-critical if we can't write PID file


def _remove_pid_file() -> None:
    """
    Remove the PID file.

    Called when the server shuts down or when --stop terminates a server.
    """
    pid_file = _get_pid_file()
    try:
        pid_file.unlink(missing_ok=True)
    except OSError:
        pass


def _read_pid_file() -> Optional[int]:
    """
    Read the PID from the PID file.

    Returns:
        The process ID as an integer, or None if the file doesn't exist
        or contains invalid data.
    """
    pid_file = _get_pid_file()
    try:
        if pid_file.exists():
            pid_str = pid_file.read_text().strip()
            return int(pid_str)
    except (OSError, ValueError):
        pass
    return None


# =============================================================================
# PROCESS MANAGEMENT
# =============================================================================
# Cross-platform utilities for checking if a process exists and terminating it.


def _is_process_running(pid: int) -> bool:
    """
    Check if a process with the given PID is currently running.

    Uses platform-specific methods:
    - Windows: Opens the process handle using ctypes/kernel32
    - Unix: Sends signal 0 (which doesn't kill but checks existence)

    Args:
        pid: The process ID to check.

    Returns:
        True if the process is running, False otherwise.
    """
    if sys.platform == "win32":
        # Windows: Use ctypes to call kernel32.OpenProcess
        # This is the standard way to check process existence on Windows
        # without requiring additional dependencies like psutil.
        import ctypes

        kernel32 = ctypes.windll.kernel32

        # PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
        # This is the minimum access right needed to query process info
        PROCESS_QUERY_LIMITED_INFORMATION = 0x1000

        handle = kernel32.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, False, pid)
        if handle:
            kernel32.CloseHandle(handle)
            return True
        return False
    else:
        # Unix: Signal 0 doesn't actually send a signal, but checks
        # if the process exists and we have permission to signal it
        try:
            os.kill(pid, 0)
            return True
        except OSError:
            return False


def _terminate_process(pid: int) -> bool:
    """
    Terminate a process by its PID.

    Uses platform-specific methods:
    - Windows: Uses taskkill command with /F (force) flag
    - Unix: Sends SIGTERM signal

    Args:
        pid: The process ID to terminate.

    Returns:
        True if termination was successful, False otherwise.
    """
    if sys.platform == "win32":
        # Windows: Use taskkill command
        # /F = force termination, /PID = specify process ID
        import subprocess

        try:
            result = subprocess.run(
                ["taskkill", "/F", "/PID", str(pid)],
                capture_output=True,
                text=True,
            )
            return result.returncode == 0
        except OSError:
            return False
    else:
        # Unix: Send SIGTERM for graceful shutdown
        try:
            os.kill(pid, signal.SIGTERM)
            return True
        except OSError:
            return False


# =============================================================================
# ARGUMENT PARSER
# =============================================================================


def _create_parser() -> argparse.ArgumentParser:
    """
    Create and configure the command-line argument parser.

    Returns:
        Configured ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="vortex",
        description="Vortex - Fast, cross-platform file transfer over local Wi-Fi",
    )

    # Server control commands
    parser.add_argument(
        "--start",
        action="store_true",
        help="Start the Vortex file gateway server",
    )
    parser.add_argument(
        "--stop",
        action="store_true",
        help="Stop a running Vortex server",
    )

    # Server configuration
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help=f"Port to listen on (default: {DEFAULT_PORT})",
    )
    parser.add_argument(
        "--dir",
        default=DEFAULT_DIR,
        help="Directory to share (default: current directory)",
    )
    parser.add_argument(
        "--max-parallel",
        type=int,
        default=DEFAULT_MAX_PARALLEL,
        help=f"Max parallel uploads from browser (default: {DEFAULT_MAX_PARALLEL})",
    )

    return parser


# =============================================================================
# MAIN ENTRY POINT
# =============================================================================


def main() -> None:
    """
    Parse command-line arguments and execute the appropriate action.

    This is the main entry point for the `vortex` command.
    """
    parser = _create_parser()
    args = parser.parse_args()

    # --- Handle --stop ---
    if args.stop:
        pid = _read_pid_file()

        if pid is None:
            print("No running Vortex server found.")
            return

        if not _is_process_running(pid):
            print(f"Vortex server (PID {pid}) is not running.")
            _remove_pid_file()
            return

        print(f"Stopping Vortex server (PID {pid})...")
        if _terminate_process(pid):
            _remove_pid_file()
            print("Vortex deactivated.")
        else:
            print("Failed to stop Vortex server.")
        return

    # --- Handle --start ---
    if args.start:
        # Check if already running
        existing_pid = _read_pid_file()
        if existing_pid and _is_process_running(existing_pid):
            print(f"Vortex is already running (PID {existing_pid}).")
            print("Use 'vortex --stop' to stop it first.")
            return

        # Write PID file and start server
        _write_pid_file()
        try:
            run_server(args.dir, args.port, args.max_parallel)
        finally:
            _remove_pid_file()
        return

    # --- No action specified ---
    parser.print_help()
</file>

<file path="src/server.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
HTTP server implementation for Vortex file gateway.

This module provides the core HTTP server functionality including:
- Thread pool-based server for concurrent connection handling
- Request handler with streaming file transfers
- HTTP Range request support for media seeking
- Directory ZIP download capability
- Security hardening (path traversal protection, security headers)
"""

import io
import os
import socket
import zipfile
from concurrent.futures import ThreadPoolExecutor
from email.utils import formatdate
from http.server import HTTPServer, SimpleHTTPRequestHandler
from pathlib import Path
from typing import Any, Callable, Optional, Tuple
from urllib.parse import parse_qs, urlparse

from .constants import (
    CHUNK_SIZE,
    CONTENT_TYPE_HTML,
    CONTENT_TYPE_MULTIPART,
    CONTENT_TYPE_ZIP,
    DNS_SERVER,
    ENCODING,
    FALLBACK_IP,
    MAX_WORKERS,
)
from .ui import render_directory_listing
from .upload import UploadResult, extract_boundary, parse_multipart_streaming
from .utils import generate_etag, get_mime_type, is_path_safe, parse_range_header


# =============================================================================
# THREAD POOL SERVER
# =============================================================================


class PooledHTTPServer(HTTPServer):
    """
    HTTP server using a thread pool for controlled concurrency.

    Uses ThreadPoolExecutor to limit maximum concurrent connections,
    preventing resource exhaustion under high load while maintaining
    high throughput for file transfers.

    Attributes:
        executor: Thread pool for handling requests.
        allow_reuse_address: Enables socket reuse to avoid bind errors.
    """

    def __init__(
        self,
        server_address: Tuple[str, int],
        RequestHandlerClass: Callable[..., SimpleHTTPRequestHandler],
        max_workers: int = MAX_WORKERS,
    ) -> None:
        """
        Initialize the pooled HTTP server.

        Args:
            server_address: Tuple of (host, port) to bind to.
            RequestHandlerClass: Handler class for processing requests.
            max_workers: Maximum concurrent connections (default: 100).
        """
        super().__init__(server_address, RequestHandlerClass)
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.allow_reuse_address = True
        self._shutdown_flag = False

    def process_request(
        self, request: socket.socket, client_address: Tuple[str, int]
    ) -> None:
        """Submit request to thread pool instead of blocking."""
        if not self._shutdown_flag:
            self.executor.submit(
                self._process_request_thread, request, client_address
            )

    def _process_request_thread(
        self, request: socket.socket, client_address: Tuple[str, int]
    ) -> None:
        """Process a single request in a thread pool worker."""
        try:
            self.finish_request(request, client_address)
        except (ConnectionResetError, ConnectionAbortedError, BrokenPipeError, OSError):
            # Client disconnected - normal behavior, no logging needed
            pass
        except Exception:
            self.handle_error(request, client_address)
        finally:
            self.shutdown_request(request)

    def handle_error(
        self, request: socket.socket, client_address: Tuple[str, int]
    ) -> None:
        """Silently handle errors for cleaner output."""
        pass

    def shutdown(self) -> None:
        """Shutdown the server and thread pool."""
        self._shutdown_flag = True
        super().shutdown()

    def server_close(self) -> None:
        """Clean up the thread pool when server closes."""
        self._shutdown_flag = True
        super().server_close()
        self.executor.shutdown(wait=False, cancel_futures=True)


# =============================================================================
# HTTP REQUEST HANDLER
# =============================================================================


class VortexHandler(SimpleHTTPRequestHandler):
    """
    HTTP request handler for serving files and accepting uploads.

    Features:
        - HTTP Range requests for media seeking and download resumption
        - Chunked file streaming for memory-efficient large transfers
        - Comprehensive MIME type detection
        - Proper caching headers (ETag, Last-Modified, Cache-Control)
        - Security headers (X-Content-Type-Options, X-Frame-Options)
        - Path traversal protection
        - Robust error handling for network and filesystem errors

    Attributes:
        base_directory: Root directory being served (absolute path).
        protocol_version: HTTP/1.1 for persistent connections.
    """

    base_directory: str
    protocol_version = "HTTP/1.1"

    def __init__(
        self,
        *args: Any,
        directory: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """
        Initialize the request handler.

        Args:
            directory: Directory to serve. Defaults to current directory.
        """
        if directory is None:
            directory = os.getcwd()
        self.base_directory = os.path.abspath(directory)
        super().__init__(*args, directory=directory, **kwargs)

    def setup(self) -> None:
        """Set up the connection with optimized socket options."""
        super().setup()
        try:
            # Increase socket buffer sizes for better throughput
            self.connection.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 256 * 1024)
            self.connection.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 256 * 1024)
            # Disable Nagle's algorithm for lower latency
            self.connection.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        except (OSError, AttributeError):
            pass  # Not all systems support these options

    def log_message(self, format: str, *args: Any) -> None:
        """Suppress default logging for cleaner output."""
        pass

    # -------------------------------------------------------------------------
    # Security Helpers
    # -------------------------------------------------------------------------

    def _send_security_headers(self) -> None:
        """Send security headers to prevent common attacks."""
        # Prevent MIME type sniffing attacks
        self.send_header("X-Content-Type-Options", "nosniff")
        # Prevent clickjacking by disallowing framing
        self.send_header("X-Frame-Options", "DENY")

    def _is_request_path_safe(self, path: str) -> bool:
        """
        Validate that a request path is safely within base_directory.

        Prevents directory traversal attacks using "../" or symlinks.

        Args:
            path: The filesystem path to validate.

        Returns:
            True if the path is safe, False otherwise.
        """
        return is_path_safe(Path(path), Path(self.base_directory))

    # -------------------------------------------------------------------------
    # Response Helpers
    # -------------------------------------------------------------------------

    def _send_html(self, content: str, status: int = 200) -> None:
        """Send an HTML response with proper headers."""
        encoded = content.encode(ENCODING, "surrogateescape")
        self.send_response(status)
        self.send_header("Content-Type", CONTENT_TYPE_HTML)
        self.send_header("Content-Length", str(len(encoded)))
        self._send_security_headers()
        self.end_headers()
        self.wfile.write(encoded)

    def _send_error_safe(self, code: int, message: str) -> None:
        """Send error response, catching any connection errors."""
        try:
            self.send_error(code, message)
        except (BrokenPipeError, ConnectionResetError, ConnectionAbortedError):
            pass

    # -------------------------------------------------------------------------
    # ZIP Download Handler
    # -------------------------------------------------------------------------

    def _handle_zip_download(self, dir_path: str, include_body: bool = True) -> None:
        """
        Handle a request to download directory contents as a ZIP file.

        Creates an in-memory ZIP archive of all files in the directory
        (not recursive) and streams it to the client.

        Args:
            dir_path: Path to the directory to zip.
            include_body: Whether to include body (False for HEAD requests).
        """
        directory = Path(dir_path)
        dir_name = directory.name or "download"
        zip_filename = f"{dir_name}.zip"

        # Build ZIP in memory to determine size for Content-Length
        zip_buffer = io.BytesIO()

        try:
            with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
                for entry in directory.iterdir():
                    try:
                        if entry.is_file():
                            zf.write(entry, entry.name)
                    except (OSError, PermissionError):
                        continue
        except Exception as e:
            self._send_error_safe(500, f"Failed to create ZIP: {e}")
            return

        zip_size = zip_buffer.tell()
        zip_buffer.seek(0)

        if zip_size == 0:
            self._send_error_safe(404, "No files to download")
            return

        # Send response
        self.send_response(200)
        self.send_header("Content-Type", CONTENT_TYPE_ZIP)
        self.send_header("Content-Length", str(zip_size))
        self.send_header(
            "Content-Disposition", f'attachment; filename="{zip_filename}"'
        )
        self.send_header("Cache-Control", "no-cache")
        self._send_security_headers()
        self.end_headers()

        # Stream ZIP content
        if include_body:
            try:
                while True:
                    chunk = zip_buffer.read(CHUNK_SIZE)
                    if not chunk:
                        break
                    self.wfile.write(chunk)
            except (BrokenPipeError, ConnectionResetError, ConnectionAbortedError):
                pass

    # -------------------------------------------------------------------------
    # File Streaming
    # -------------------------------------------------------------------------

    def _stream_file(self, file_path: str, start: int, end: int) -> bool:
        """
        Stream a file range to the client in chunks.

        Args:
            file_path: Path to the file to stream.
            start: Starting byte position.
            end: Ending byte position (inclusive).

        Returns:
            True if streaming completed successfully, False otherwise.
        """
        bytes_to_send = end - start + 1

        try:
            with open(file_path, "rb") as f:
                f.seek(start)
                remaining = bytes_to_send

                while remaining > 0:
                    chunk_size = min(CHUNK_SIZE, remaining)
                    chunk = f.read(chunk_size)
                    if not chunk:
                        break
                    self.wfile.write(chunk)
                    remaining -= len(chunk)

            return True
        except (BrokenPipeError, ConnectionResetError, ConnectionAbortedError):
            return False
        except OSError:
            return False

    # -------------------------------------------------------------------------
    # HTTP Method Handlers
    # -------------------------------------------------------------------------

    def do_HEAD(self) -> None:
        """Handle HEAD requests (same as GET but without body)."""
        self._handle_get_or_head(include_body=False)

    def do_GET(self) -> None:
        """
        Handle GET requests for directory listings and file downloads.

        Supports HTTP Range requests for media seeking and download resumption.
        Uses chunked streaming for memory-efficient large file transfers.
        """
        self._handle_get_or_head(include_body=True)

    def _handle_get_or_head(self, include_body: bool = True) -> None:
        """Common handler for GET and HEAD requests."""
        # Parse URL for query parameters
        parsed = urlparse(self.path)
        query_params = parse_qs(parsed.query)
        path = self.translate_path(parsed.path)

        # Security: Validate path is within base directory
        if not self._is_request_path_safe(path):
            self._send_error_safe(403, "Access denied")
            return

        # --- Directory Handling ---
        if os.path.isdir(path):
            # ZIP download request
            if query_params.get("download") == ["zip"]:
                self._handle_zip_download(path, include_body)
                return

            # Regular directory listing
            try:
                html_page = render_directory_listing(
                    self.base_directory, path, parsed.path
                )
                self._send_html(html_page)
            except (OSError, PermissionError) as e:
                self._send_error_safe(403, f"Cannot access directory: {e}")
            return

        # --- File Not Found ---
        if not os.path.isfile(path):
            self._send_error_safe(404, "File not found")
            return

        # --- File Handling ---
        try:
            file_stat = os.stat(path)
            file_size = file_stat.st_size
        except OSError as e:
            self._send_error_safe(403, f"Cannot access file: {e}")
            return

        # Generate response headers
        mime_type = get_mime_type(path)
        etag = generate_etag(path, file_stat)
        last_modified = formatdate(file_stat.st_mtime, usegmt=True)
        filename = os.path.basename(path)

        # Check If-None-Match for caching (304 Not Modified)
        if_none_match = self.headers.get("If-None-Match")
        if if_none_match and if_none_match == etag:
            self.send_response(304)
            self.end_headers()
            return

        # --- Range Request Handling ---
        range_header = self.headers.get("Range")

        if range_header:
            byte_range = parse_range_header(range_header, file_size)

            if byte_range is None:
                # Invalid range - send 416 Range Not Satisfiable
                self.send_response(416)
                self.send_header("Content-Range", f"bytes */{file_size}")
                self.end_headers()
                return

            start, end = byte_range
            content_length = end - start + 1

            # Send 206 Partial Content
            self.send_response(206)
            self.send_header("Content-Range", f"bytes {start}-{end}/{file_size}")
        else:
            # Full file request
            start, end = 0, file_size - 1
            content_length = file_size
            self.send_response(200)

        # --- Send Headers ---
        self.send_header("Content-Type", mime_type)
        self.send_header("Content-Length", str(content_length))
        self.send_header("Accept-Ranges", "bytes")
        self.send_header("ETag", etag)
        self.send_header("Last-Modified", last_modified)
        self.send_header("Cache-Control", "public, max-age=3600")
        self.send_header("Content-Disposition", f'inline; filename="{filename}"')
        self._send_security_headers()
        self.end_headers()

        # Stream file content (skip for HEAD requests)
        if include_body and content_length > 0:
            self._stream_file(path, start, end)

    def do_POST(self) -> None:
        """
        Handle POST requests for file uploads via multipart/form-data.

        Uses streaming to handle large files without loading them entirely
        into memory. This allows uploading files of any size smoothly.
        """
        content_type = self.headers.get("Content-Type", "")

        if CONTENT_TYPE_MULTIPART not in content_type:
            self._send_error_safe(400, "Expected multipart/form-data")
            return

        boundary = extract_boundary(content_type)
        if not boundary:
            self._send_error_safe(400, "No multipart boundary found")
            return

        try:
            length = int(self.headers.get("Content-Length", "0"))
        except ValueError:
            self._send_error_safe(400, "Missing or invalid Content-Length")
            return

        if length <= 0:
            self._send_error_safe(400, "Invalid Content-Length")
            return

        # Security: Validate upload path is within base directory
        if not self._is_request_path_safe(self.base_directory):
            self._send_error_safe(403, "Access denied")
            return

        # Stream upload to disk
        try:
            result: UploadResult = parse_multipart_streaming(
                self.rfile, length, boundary, self.base_directory
            )
        except (BrokenPipeError, ConnectionResetError, ConnectionAbortedError):
            return

        if not result.success:
            self._send_error_safe(400, result.error_message or "Upload failed")
            return

        # Redirect back to root after successful upload
        try:
            self.send_response(303)
            self.send_header("Location", "/")
            self.end_headers()
        except (BrokenPipeError, ConnectionResetError, ConnectionAbortedError):
            pass


# =============================================================================
# NETWORK UTILITIES
# =============================================================================


def get_local_ip() -> str:
    """
    Detect the local LAN IP address for shareable URLs.

    Uses a UDP socket to determine which local IP would be used
    to reach an external address. This works without actually
    sending any data, just by checking routing.

    Returns:
        The local IP address (e.g., "192.168.1.100"), or "127.0.0.1"
        if detection fails.
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        sock.connect(DNS_SERVER)
        return sock.getsockname()[0]
    except OSError:
        return FALLBACK_IP
    finally:
        sock.close()


# =============================================================================
# SERVER ENTRY POINT
# =============================================================================


def run_server(directory: str, port: int, max_parallel: int = 4) -> None:
    """
    Start the Vortex HTTP server.

    Args:
        directory: Path to the directory to serve.
        port: Port number to listen on.
        max_parallel: Max parallel uploads hint for browser (unused server-side).

    The server uses a thread pool to handle multiple concurrent connections
    efficiently, with limits to prevent resource exhaustion.
    """
    resolved_directory = str(Path(directory).resolve())

    def handler_factory(*args: Any, **kwargs: Any) -> VortexHandler:
        return VortexHandler(*args, directory=resolved_directory, **kwargs)

    server_address = ("0.0.0.0", port)
    httpd = PooledHTTPServer(server_address, handler_factory, max_workers=MAX_WORKERS)

    ip = get_local_ip()
    print("Vortex active")
    print(f"Serving directory: {resolved_directory}")
    print(f"Share this on your Wi-Fi:  http://{ip}:{port}/")
    print(f"Max concurrent connections: {MAX_WORKERS}")
    print("Press Ctrl+C to stop.")

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        print("\nVortex deactivated.")
        httpd.shutdown()
        httpd.server_close()
</file>

<file path="src/ui.py">
# MIT License
# Copyright (c) 2024 Vortex Contributors
# See LICENSE file for full license text.

"""
UI rendering module for Vortex file gateway.

This module provides HTML template rendering for the directory listing
and file upload interface. It generates a responsive, mobile-friendly
web UI for browsing and uploading files.
"""

import html
import os
from pathlib import Path
from typing import List
from urllib.parse import unquote

from .scripts import JS_UPLOAD_HANDLER
from .styles import CSS_STYLESHEET


# =============================================================================
# SIZE FORMATTING
# =============================================================================

# Units for human-readable file sizes
_SIZE_UNITS = ("B", "KB", "MB", "GB", "TB", "PB")
_SIZE_THRESHOLD = 1024.0


def format_size(size_bytes: int) -> str:
    """
    Format a file size in bytes to a human-readable string.

    Args:
        size_bytes: File size in bytes.

    Returns:
        Human-readable size string (e.g., "1.5 MB", "256 KB").
    """
    size = float(size_bytes)
    for unit in _SIZE_UNITS[:-1]:
        if size < _SIZE_THRESHOLD:
            return f"{size:3.1f} {unit}"
        size /= _SIZE_THRESHOLD
    return f"{size:.1f} {_SIZE_UNITS[-1]}"


# =============================================================================
# HTML LAYOUT
# =============================================================================


def render_layout(title: str, body_html: str) -> str:
    """
    Render the main HTML layout with header, body content, and footer.

    This is the outer shell of the web interface, providing consistent
    styling and structure across all pages.

    Args:
        title: Page title for the browser tab.
        body_html: HTML content to insert into the main body area.

    Returns:
        Complete HTML document as a string.
    """
    escaped_title = html.escape(title)

    return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="format-detection" content="telephone=no">
<meta name="theme-color" content="#e8e4e0">
<title>{escaped_title}</title>
<style>{CSS_STYLESHEET}</style>
</head>
<body>
  <div class="app-root">
    <div class="device-shell">
      <header class="device-header">
        <h1>Vortex</h1>
        <p>Local file gateway</p>
      </header>
      {body_html}
      <footer class="device-footer">
        <span class="label">Status</span>
        <span class="value">Listening...</span>
      </footer>
    </div>
  </div>
<script>{JS_UPLOAD_HANDLER}</script>
</body>
</html>
"""


# =============================================================================
# DIRECTORY LISTING
# =============================================================================


def _build_file_table_rows(real_path: Path, base_directory: str) -> List[str]:
    """
    Build HTML table rows for directory entries.

    Creates a table row for each file and subdirectory, including
    a parent directory link ("..") when not at the root.

    Args:
        real_path: Path to the directory being listed.
        base_directory: Root directory being served.

    Returns:
        List of HTML table row strings.
    """
    rows: List[str] = []

    # Add parent directory link if not at root
    rel = os.path.relpath(real_path, base_directory)
    if rel != ".":
        rows.append('<tr><td><a href="../">[..]</a></td><td></td></tr>')

    # Sort entries case-insensitively
    try:
        entries = sorted(real_path.iterdir(), key=lambda p: p.name.lower())
    except (OSError, PermissionError):
        # Cannot read directory - return what we have
        return rows

    for entry in entries:
        try:
            is_dir = entry.is_dir()
            name = entry.name + ("/" if is_dir else "")
            escaped_name = html.escape(name)

            if is_dir:
                size = "-"
            else:
                try:
                    size = format_size(entry.stat().st_size)
                except (OSError, PermissionError):
                    size = "?"  # Cannot stat file

            rows.append(
                f'<tr><td><a href="{escaped_name}">{escaped_name}</a></td>'
                f"<td>{size}</td></tr>"
            )
        except (OSError, PermissionError):
            # Skip entries we cannot access
            continue

    return rows


def render_directory_listing(
    base_directory: str,
    fs_path: str,
    request_path: str,
) -> str:
    """
    Build the complete HTML page for a directory listing.

    Includes the upload panel and file table with all entries
    in the specified directory.

    Args:
        base_directory: Root directory being served.
        fs_path: Filesystem path to the current directory.
        request_path: URL path from the HTTP request.

    Returns:
        Complete HTML page for the directory listing.
    """
    real_path = Path(fs_path)
    display_path = html.escape(unquote(request_path))
    base_name = html.escape(os.path.basename(base_directory) or "/")

    # Build file table rows
    rows = _build_file_table_rows(real_path, base_directory)

    # Count files (not directories) for Download All button
    file_count = 0
    try:
        for entry in real_path.iterdir():
            try:
                if entry.is_file():
                    file_count += 1
            except (OSError, PermissionError):
                continue
    except (OSError, PermissionError):
        pass

    # Build the file table HTML
    table_html = (
        "<table>"
        "<thead><tr><th>Name</th><th>Size</th></tr></thead>"
        "<tbody>" + "".join(rows) + "</tbody></table>"
    )

    # Download All button (only shown if there are files)
    download_btn = ""
    if file_count > 0:
        download_btn = (
            f'<a class="btn btn-download" href="?download=zip">'
            f"Download All ({file_count})</a>"
        )

    # Subheader shows current path and base directory
    subheader = f"""
      <div class="device-subheader">
        <span>Serving: {html.escape(str(base_directory))}</span>
        <span>{display_path}</span>
      </div>
    """

    # Main content with upload panel and file list
    main_content = f"""
    <main class="device-main">
      <section class="panel panel-files">
        <div class="panel-title">
          <span>Files</span>
          <span>{display_path}</span>
        </div>
        {download_btn}
        <div class="file-list">
          {table_html}
        </div>
      </section>
      <section class="panel panel-upload">
        <div class="panel-title">
          <span>Upload</span>
          <span>{base_name}</span>
        </div>
        <p class="path-label">Select files to upload (no size limit)</p>
        <form method="post" enctype="multipart/form-data">
          <div class="upload-row">
            <label class="file-input">
              <input type="file" name="file" multiple required>
              <span class="file-button">Choose files</span>
              <span class="file-name">No files selected</span>
            </label>
            <button class="btn" type="submit">Send</button>
          </div>
          <div class="upload-progress">
            <div class="progress-bar-container">
              <div class="progress-bar"></div>
            </div>
            <span class="progress-text">Uploading...</span>
          </div>
          <div class="upload-error"></div>
        </form>
      </section>
    </main>
    """

    return render_layout("Vortex", subheader + main_content)
</file>

</files>
